SchemaCrawler http://schemacrawler.sourceforge.net/ - db meta access
jOOQ http://www.jooq.org
http://ikaisays.com/2011/11/01/getting-started-with-jooq-a-tutorial/
Querydsl http://www.querydsl.com/
http://www.springfuse.com/, Celerio - code generator tool http://www.jaxio.com/en/celerio.html
Liquibase - database changes
Lucene - полнотекствый поиск

hibernate JdbcServicesImpl


 dbsupport - только модель базы данных, диалекты и прочая специфика
 dao - работа с конкретным соединением
 service - утилитарный слой
 entity - сущности приложения как таковые

 EntityManager или имплемент JPA
 Criterias, etc



 http://www.springbyexample.org/examples/spring-data-jpa.html
 http://docs.jboss.org/hibernate/entitymanager/3.6/reference/en/html_single/
http://gordondickens.com/wordpress/2011/08/01/simpler-jpa-with-spring-data-jpa/
http://docs.oracle.com/javaee/6/tutorial/doc/gjivm.html

 ZK: http://habrahabr.ru/post/129189/


 Automated Business Logic http://www.automatedbusinesslogic.com/downloads-1



// see http://www.manydesigns.com/en/blog/configuring-hibernate-programmatically logical model

TODO:
  class is not exists (Employee) and we get exception NPE when try to retrive class
  line 69 AbstractAttributeContainer

1. Build ServiceRegistry instance
2. MetadataSources metadataSources = new MetadataSources(serviceRegistry);
    2.1 metadataSources.metadataBuilder = new MetadataBuilderImpl( this );
3. Configure metadataSources sources (hbm, annotations, etc)
4. Metadata metadata = metadataSources.buildMetadata();
    4.1 metadataSources.getMetadataBuilder().buildMetadata();
        4.1.1 metadataSources.metadataBuilder: new MetadataImpl( sources, options );
5. sessionFactory = metadata.buildSessionFactory();




2013-03-01
1. у TableMeta в специальном поле описываем тип привязки:
  1.1 map - instance динамический map
  1.2 class - instance будет какой-то неаннотированный класс (т.е. он будет привязан через MetaMappingBinder)
  1.3 mapped class - instance будет аннотированный класс, который добавиться в mapping-annotations classes для конфига,
  при этом сам TableMeta будет помечен как shadow и все данные заново проинициализованы из аннотаций
  TableMeta может быть снят флаг shadow - тогда класс будет map

  Meta таблицы также есть в списке TableMeta - но помеченные как shadow (final) - т.е. они всегда определяются из своих аннотированных классов.

  Генератор кода

2. можно дополнительно описывать какие-то маппинги руками в конфиге (hbm или аннотированные классы),
 они также переопределяеют TableMeta при наличии такого-же (shadow, readonly), но без возможности снятия флага shadow
 ? - чтобы можно было ссылаться на такой класс, нужно или отменить FK check (останется только имя таблицы/поля) или хранить их в БД как transient

3. TableMeta источник данных - view,sql,hql - список полей заполнятся динамически. read-only.
Можно описать insert,update,delete - тогда не read-only

4. DataSource - (может п.2 перенести на уровень datasource) - описывает источник данных (на основании какой-то таблицы) и список полей.
...

5. Генераторы
 для поля можно указать генератор - имя класс которое его генерит при создании нового(action -create/update обрабатывается на уровне генератора).
 По умолчанию с списке все генераторы на уровне classpath наследники интерфейса IGenerator.
 В т.ч. все hibernate генераторы (сделать бриджи).
 Генератор может использоваться не только для id.

6. DAO access слой для любых entity.

7. Несколько datasource/sessionFactory - можно подключать несколько источником данных. -> Слабые (без FK) и сильные (с FK) ссылки для связей между источниками данных.
Для каждого источника данных прописыается набор TableMeta за которые он ответственных.
TableMeta шарится на все приложение.


8. Подумать над представлением TableMeta - как хранить FK (их hibernate генерит сам), см. MetaMappingBinder foreign-key.
Может все хранить в одном списке (колонки, связи, ключи, и т.д.) - как в hbm?

9. Meta general - описывает вообще все источники данных (DD_TABLE как из БД, веб-сервисы, xml, json, файлы)
для каждого вида источника - свои таблицы, поддержка несколько разных БД
не хранится в БД - только в файле, все допустимые БД тоже из файла
заполняется в рантайм

10. Keep in mind: all binder method needs to be reviewed from time to time


2013-03-07 TODO
 add Properties to *Meta classes: persist as string but will be parsed in runtime
 support all custom properties in TODOs from this field


2013-03-14 TODO
   !!!! Metamodel ignores dynamic-map-entity mode,
   при создании createEntityPersister
   DatabaseModelMetadataImpl.makeClassReference(final String className)
    className = null always
ожидается в версии 5.0
   переписать через маппинги
